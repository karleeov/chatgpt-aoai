// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { RestError, createHttpHeaders, createPipelineRequest, } from "@azure/core-rest-pipeline";
import { getCachedDefaultHttpsClient } from "./clientHelpers";
import { isReadableStream } from "./helpers/isReadableStream";
import { binaryArrayToString } from "./helpers/getBinaryBody";
/**
 * Helper function to send request used by the client
 * @param method - method to use to send the request
 * @param url - url to send the request to
 * @param pipeline - pipeline with the policies to run when sending the request
 * @param options - request options
 * @param customHttpClient - a custom HttpClient to use when making the request
 * @returns returns and HttpResponse
 */
export async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
    const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
    const request = buildPipelineRequest(method, url, options);
    const response = await pipeline.sendRequest(httpClient, request);
    const rawHeaders = response.headers.toJSON();
    const parsedBody = getResponseBody(response);
    if (options === null || options === void 0 ? void 0 : options.onResponse) {
        options.onResponse(Object.assign(Object.assign({}, response), { request, rawHeaders, parsedBody }));
    }
    return {
        request,
        headers: rawHeaders,
        status: `${response.status}`,
        body: parsedBody,
    };
}
/**
 * Helper function to send request used by the client
 * @param method - method to use to send the request
 * @param url - url to send the request to
 * @param pipeline - pipeline with the policies to run when sending the request
 * @param options - request options
 * @param customHttpClient - a custom HttpClient to use when making the request
 * @returns returns and HttpResponse
 */
export async function sendRequestAsStream(method, url, pipeline, options = {}, customHttpClient) {
    var _a;
    const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
    const request = buildPipelineRequest(method, url, Object.assign(Object.assign({}, options), { responseAsStream: true }));
    const response = await pipeline.sendRequest(httpClient, request);
    const rawHeaders = response.headers.toJSON();
    const parsedBody = (_a = response.browserStreamBody) !== null && _a !== void 0 ? _a : response.readableStreamBody;
    return {
        request,
        headers: rawHeaders,
        status: `${response.status}`,
        body: parsedBody,
    };
}
/**
 * Function to determine the content-type of a body
 * this is used if an explicit content-type is not provided
 * @param body - body in the request
 * @returns returns the content-type
 */
function getContentType(body) {
    if (ArrayBuffer.isView(body)) {
        return "application/octet-stream";
    }
    // By default return json
    return "application/json; charset=UTF-8";
}
function buildPipelineRequest(method, url, options = {}) {
    var _a, _b;
    const { body, formData } = getRequestBody(options.body, options.contentType);
    const hasContent = body !== undefined || formData !== undefined;
    const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, (options.headers ? options.headers : {})), { accept: (_a = options.accept) !== null && _a !== void 0 ? _a : "application/json" }), (hasContent && {
        "content-type": (_b = options.contentType) !== null && _b !== void 0 ? _b : getContentType(options.body),
    })));
    return createPipelineRequest({
        url,
        method,
        body,
        formData,
        headers,
        allowInsecureConnection: options.allowInsecureConnection,
        tracingOptions: options.tracingOptions,
        abortSignal: options.abortSignal,
        onUploadProgress: options.onUploadProgress,
        onDownloadProgress: options.onDownloadProgress,
        timeout: options.timeout,
        enableBrowserStreams: true,
        streamResponseStatusCodes: options.responseAsStream
            ? new Set([Number.POSITIVE_INFINITY])
            : undefined,
    });
}
/**
 * Prepares the body before sending the request
 */
function getRequestBody(body, contentType = "") {
    if (body === undefined) {
        return { body: undefined };
    }
    if (isReadableStream(body)) {
        return { body };
    }
    if (!contentType && typeof body === "string") {
        return { body };
    }
    const firstType = contentType.split(";")[0];
    if (firstType === "application/json") {
        return { body: JSON.stringify(body) };
    }
    if (ArrayBuffer.isView(body)) {
        if (body instanceof Uint8Array) {
            return { body: binaryArrayToString(body) };
        }
        else {
            return { body: JSON.stringify(body) };
        }
    }
    switch (firstType) {
        case "multipart/form-data":
            return isFormData(body)
                ? { formData: processFormData(body) }
                : { body: JSON.stringify(body) };
        case "text/plain":
            return { body: String(body) };
        default:
            if (typeof body === "string") {
                return { body };
            }
            return { body: JSON.stringify(body) };
    }
}
function isFormData(body) {
    return body instanceof Object && Object.keys(body).length > 0;
}
/**
 * Checks if binary data is in Uint8Array format, if so decode it to a binary string
 * to send over the wire
 */
function processFormData(formData) {
    if (!formData) {
        return formData;
    }
    const processedFormData = {};
    for (const element in formData) {
        const item = formData[element];
        if (item instanceof Uint8Array) {
            processedFormData[element] = binaryArrayToString(item);
        }
        else {
            processedFormData[element] = item;
        }
    }
    return processedFormData;
}
/**
 * Prepares the response body
 */
function getResponseBody(response) {
    var _a, _b;
    // Set the default response type
    const contentType = (_a = response.headers.get("content-type")) !== null && _a !== void 0 ? _a : "";
    const firstType = contentType.split(";")[0];
    const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : "";
    if (firstType === "text/plain") {
        return String(bodyToParse);
    }
    // Default to "application/json" and fallback to string;
    try {
        return bodyToParse ? JSON.parse(bodyToParse) : undefined;
    }
    catch (error) {
        // If we were supposed to get a JSON object and failed to
        // parse, throw a parse error
        if (firstType === "application/json") {
            throw createParseError(response, error);
        }
        // We are not sure how to handle the response so we return it as
        // plain text.
        return String(bodyToParse);
    }
}
function createParseError(response, err) {
    var _a;
    const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
    const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;
    return new RestError(msg, {
        code: errCode,
        statusCode: response.status,
        request: response.request,
        response: response,
    });
}
//# sourceMappingURL=sendRequest.js.map