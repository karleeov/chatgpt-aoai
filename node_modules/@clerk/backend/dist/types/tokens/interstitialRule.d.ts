import type { RequestState } from './authStatus';
import type { AuthenticateRequestOptions } from './request';
type InterstitialRuleResult = RequestState | undefined;
type InterstitialRule = <T extends AuthenticateRequestOptions>(opts: T) => Promise<InterstitialRuleResult> | InterstitialRuleResult;
export declare const nonBrowserRequestInDevRule: InterstitialRule;
export declare const crossOriginRequestWithoutHeader: InterstitialRule;
export declare const isPrimaryInDevAndRedirectsToSatellite: InterstitialRule;
export declare const potentialFirstLoadInDevWhenUATMissing: InterstitialRule;
/**
 * NOTE: Exclude any satellite app that has just synced from throwing an interstitial.
 * It is expected that a primary app will trigger a redirect back to the satellite app.
 */
export declare const potentialRequestAfterSignInOrOutFromClerkHostedUiInDev: InterstitialRule;
export declare const potentialFirstRequestOnProductionEnvironment: InterstitialRule;
export declare const isNormalSignedOutState: InterstitialRule;
export declare const hasPositiveClientUatButCookieIsMissing: InterstitialRule;
export declare const hasValidHeaderToken: InterstitialRule;
export declare const hasValidCookieToken: InterstitialRule;
export declare function runInterstitialRules<T extends AuthenticateRequestOptions>(opts: T, rules: InterstitialRule[]): Promise<RequestState>;
/**
 * Avoid throwing this rule for development instances
 * Let the next rule for UatMissing to fire if needed
 */
export declare const isSatelliteAndNeedsSyncing: InterstitialRule;
export {};
//# sourceMappingURL=interstitialRule.d.ts.map